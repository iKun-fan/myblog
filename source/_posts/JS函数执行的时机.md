# 函数调用时机

函数调用的时机不同，结果也不同。
```javascript
let a = 1
function fn() {
    console.log(a)
}

a = 2
fn()

//2
```
```javascript
let a = 1
function fn() {
    console.log(a)
}

fn()
a = 2

//1
```
这两个例子是非常好理解的，一眼就能看出调用时机的不同，所导致得的结果不同。但是异步操作会让函数调用的结果变的不那么容易理解。
```javascript
let a = 1
function fn() {
    setTimeout(()=>{
        console.log(a)
    },0)
}

fn()
a = 2

//2
```

# 单线程
JavaScript只在一个线程上执行，也就是说，JavaScript同时只执行一个任务，其他任务都必须排队执行。这是在JavaScript诞生之初就决定了的，对于主要在浏览器上运行的编程语言来说，多线程会让浏览器变的太复杂。

单线程也带来了一些坏处，当一项任务耗时很长，后面的任务就必须等待它执行完毕后才能运行，这就拖慢了整个程序的执行时间，比如在上网冲浪时，对方服务器响应速度很慢，这就会导致Javascript程序一直在等待响应，长时间停滞。

所以，JavaScript 语言的设计者意识到，等待响应的时间里完全可以将其挂起，继续执行下面的任务，等到响应完毕后再回头执行挂起的任务。

# 同步任务和异步任务
同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。

异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了，该任务才会进入主线程执行。

这就基本解释了为什么```setTimeout```的```delay```值为```0```还会导致先调用的函数居然“过了一会儿”才执行，并得到了“意料之外”的值。

# “6个6”
```javascript
let i = 0
for(i = 0; i < 6; i++) {
    setTimeout(() => {
        console.log(i)
    }, 0)
}

//打印出6个6
```
上面说过，必须要等同步任务全部结束后，才会执行被挂起的任务，也就是说，```setTimeout(function, 0)```在每次进入循环时都会被挂起，当```i = 6```时，不满足循环条件，退出循环，这时被挂起的6个```setTimeout(function, 0)```才会被执行，于是就输出了6个6。

但是，如果把声明初始化变量的语句放到```for```循环里时会出现和上面完全不同的结果。
```javascript
for(let i = 1; i < 6; i++) {
    setTimeout(() => {
        console.log(i)
    }, 0)
}

//依次打印出0，1，2，3，4，5
```
如果进行闭包也可以输出0，1，2，3，4，5
```javascript
function fx() {
    let i = 0
    for (i = 0; i < 6; i++) {
        (function (j) {
            setTimeout(function () {
                console.log(j)
            }, 0)
        })(i)
    }
}
```